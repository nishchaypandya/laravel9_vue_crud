import "./chunk-OL3AADLO.js";

// node_modules/filepond-plugin-file-poster/dist/filepond-plugin-file-poster.esm.js
var IMAGE_SCALE_SPRING_PROPS = {
  type: "spring",
  stiffness: 0.5,
  damping: 0.45,
  mass: 10
};
var createPosterView = (_) => _.utils.createView({
  name: "file-poster",
  tag: "div",
  ignoreRect: true,
  create: ({ root }) => {
    root.ref.image = document.createElement("img");
    root.element.appendChild(root.ref.image);
  },
  write: _.utils.createRoute({
    DID_FILE_POSTER_LOAD: ({ root, props }) => {
      const { id } = props;
      const item = root.query("GET_ITEM", { id: props.id });
      if (!item)
        return;
      const poster = item.getMetadata("poster");
      root.ref.image.src = poster;
      root.dispatch("DID_FILE_POSTER_DRAW", { id });
    }
  }),
  mixins: {
    styles: ["scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: IMAGE_SCALE_SPRING_PROPS,
      scaleY: IMAGE_SCALE_SPRING_PROPS,
      opacity: { type: "tween", duration: 750 }
    }
  }
});
var applyTemplate = (source, target) => {
  target.width = source.width;
  target.height = source.height;
  const ctx = target.getContext("2d");
  ctx.drawImage(source, 0, 0);
};
var createPosterOverlayView = (fpAPI) => fpAPI.utils.createView({
  name: "file-poster-overlay",
  tag: "canvas",
  ignoreRect: true,
  create: ({ root, props }) => {
    applyTemplate(props.template, root.element);
  },
  mixins: {
    styles: ["opacity"],
    animations: {
      opacity: { type: "spring", mass: 25 }
    }
  }
});
var getImageSize = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width2 = image.naturalWidth;
    const height2 = image.naturalHeight;
    image = null;
    cb(width2, height2);
  };
  image.src = url;
};
var easeInOutSine = (t) => -0.5 * (Math.cos(Math.PI * t) - 1);
var addGradientSteps = (gradient, color, alpha = 1, easeFn = easeInOutSine, steps = 10, offset = 0) => {
  const range = 1 - offset;
  const rgb = color.join(",");
  for (let i = 0; i <= steps; i++) {
    const p = i / steps;
    const stop = offset + range * p;
    gradient.addColorStop(stop, `rgba(${rgb}, ${easeFn(p) * alpha})`);
  }
};
var MAX_WIDTH = 10;
var MAX_HEIGHT = 10;
var calculateAverageColor = (image) => {
  const scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const width2 = canvas.width = Math.ceil(image.width * scalar);
  const height2 = canvas.height = Math.ceil(image.height * scalar);
  ctx.drawImage(image, 0, 0, width2, height2);
  let data = null;
  try {
    data = ctx.getImageData(0, 0, width2, height2).data;
  } catch (e) {
    return null;
  }
  const l = data.length;
  let r = 0;
  let g = 0;
  let b = 0;
  let i = 0;
  for (; i < l; i += 4) {
    r += data[i] * data[i];
    g += data[i + 1] * data[i + 1];
    b += data[i + 2] * data[i + 2];
  }
  r = averageColor(r, l);
  g = averageColor(g, l);
  b = averageColor(b, l);
  return { r, g, b };
};
var averageColor = (c, l) => Math.floor(Math.sqrt(c / (l / 4)));
var drawTemplate = (canvas, width2, height2, color, alphaTarget) => {
  canvas.width = width2;
  canvas.height = height2;
  const ctx = canvas.getContext("2d");
  const horizontalCenter = width2 * 0.5;
  const grad = ctx.createRadialGradient(
    horizontalCenter,
    height2 + 110,
    height2 - 100,
    horizontalCenter,
    height2 + 110,
    height2 + 100
  );
  addGradientSteps(grad, color, alphaTarget, void 0, 8, 0.4);
  ctx.save();
  ctx.translate(-width2 * 0.5, 0);
  ctx.scale(2, 1);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, width2, height2);
  ctx.restore();
};
var hasNavigator = typeof navigator !== "undefined";
var width = 500;
var height = 200;
var overlayTemplateShadow = hasNavigator && document.createElement("canvas");
var overlayTemplateError = hasNavigator && document.createElement("canvas");
var overlayTemplateSuccess = hasNavigator && document.createElement("canvas");
var itemShadowColor = [40, 40, 40];
var itemErrorColor = [196, 78, 71];
var itemSuccessColor = [54, 151, 99];
if (hasNavigator) {
  drawTemplate(overlayTemplateShadow, width, height, itemShadowColor, 0.85);
  drawTemplate(overlayTemplateError, width, height, itemErrorColor, 1);
  drawTemplate(overlayTemplateSuccess, width, height, itemSuccessColor, 1);
}
var loadImage = (url, crossOriginValue) => new Promise((resolve, reject) => {
  const img = new Image();
  if (typeof crossOrigin === "string") {
    img.crossOrigin = crossOriginValue;
  }
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
var createPosterWrapperView = (_) => {
  const overlay = createPosterOverlayView(_);
  const didCreatePreviewContainer = ({ root, props }) => {
    const { id } = props;
    const item = root.query("GET_ITEM", id);
    if (!item)
      return;
    const fileURL = item.getMetadata("poster");
    const previewImageLoaded = (data) => {
      const averageColor2 = root.query(
        "GET_FILE_POSTER_CALCULATE_AVERAGE_IMAGE_COLOR"
      ) ? calculateAverageColor(data) : null;
      item.setMetadata("color", averageColor2, true);
      root.dispatch("DID_FILE_POSTER_LOAD", {
        id,
        data
      });
    };
    getImageSize(fileURL, (width2, height2) => {
      root.dispatch("DID_FILE_POSTER_CALCULATE_SIZE", {
        id,
        width: width2,
        height: height2
      });
      loadImage(
        fileURL,
        root.query("GET_FILE_POSTER_CROSS_ORIGIN_ATTRIBUTE_VALUE")
      ).then(previewImageLoaded);
    });
  };
  const didLoadPreview = ({ root }) => {
    root.ref.overlayShadow.opacity = 1;
  };
  const didDrawPreview = ({ root }) => {
    const { image } = root.ref;
    image.scaleX = 1;
    image.scaleY = 1;
    image.opacity = 1;
  };
  const restoreOverlay = ({ root }) => {
    root.ref.overlayShadow.opacity = 1;
    root.ref.overlayError.opacity = 0;
    root.ref.overlaySuccess.opacity = 0;
  };
  const didThrowError = ({ root }) => {
    root.ref.overlayShadow.opacity = 0.25;
    root.ref.overlayError.opacity = 1;
  };
  const didCompleteProcessing = ({ root }) => {
    root.ref.overlayShadow.opacity = 0.25;
    root.ref.overlaySuccess.opacity = 1;
  };
  const create = ({ root, props }) => {
    const itemShadowColorProp = root.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_SHADOW_COLOR"
    );
    const itemErrorColorProp = root.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_ERROR_COLOR"
    );
    const itemSuccessColorProp = root.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_SUCCESS_COLOR"
    );
    if (itemShadowColorProp && itemShadowColorProp !== itemShadowColor) {
      itemShadowColor = itemShadowColorProp;
      drawTemplate(overlayTemplateShadow, width, height, itemShadowColor, 0.85);
    }
    if (itemErrorColorProp && itemErrorColorProp !== itemErrorColor) {
      itemErrorColor = itemErrorColorProp;
      drawTemplate(overlayTemplateError, width, height, itemErrorColor, 1);
    }
    if (itemSuccessColorProp && itemSuccessColorProp !== itemSuccessColor) {
      itemSuccessColor = itemSuccessColorProp;
      drawTemplate(overlayTemplateSuccess, width, height, itemSuccessColor, 1);
    }
    const image = createPosterView(_);
    root.ref.image = root.appendChildView(
      root.createChildView(image, {
        id: props.id,
        scaleX: 1.25,
        scaleY: 1.25,
        opacity: 0
      })
    );
    root.ref.overlayShadow = root.appendChildView(
      root.createChildView(overlay, {
        template: overlayTemplateShadow,
        opacity: 0
      })
    );
    root.ref.overlaySuccess = root.appendChildView(
      root.createChildView(overlay, {
        template: overlayTemplateSuccess,
        opacity: 0
      })
    );
    root.ref.overlayError = root.appendChildView(
      root.createChildView(overlay, {
        template: overlayTemplateError,
        opacity: 0
      })
    );
  };
  return _.utils.createView({
    name: "file-poster-wrapper",
    create,
    write: _.utils.createRoute({
      DID_FILE_POSTER_LOAD: didLoadPreview,
      DID_FILE_POSTER_DRAW: didDrawPreview,
      DID_FILE_POSTER_CONTAINER_CREATE: didCreatePreviewContainer,
      DID_THROW_ITEM_LOAD_ERROR: didThrowError,
      DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,
      DID_THROW_ITEM_INVALID: didThrowError,
      DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,
      DID_START_ITEM_PROCESSING: restoreOverlay,
      DID_REVERT_ITEM_PROCESSING: restoreOverlay
    })
  });
};
var plugin = (fpAPI) => {
  const { addFilter, utils } = fpAPI;
  const { Type, createRoute } = utils;
  const filePosterView = createPosterWrapperView(fpAPI);
  addFilter("CREATE_VIEW", (viewAPI) => {
    const { is, view, query } = viewAPI;
    if (!is("file") || !query("GET_ALLOW_FILE_POSTER"))
      return;
    const didLoadItem = ({ root, props }) => {
      updateItemPoster(root, props);
    };
    const didUpdateItemMetadata = ({ root, props, action }) => {
      if (!/poster/.test(action.change.key))
        return;
      updateItemPoster(root, props);
    };
    const updateItemPoster = (root, props) => {
      const { id } = props;
      const item = query("GET_ITEM", id);
      if (!item || !item.getMetadata("poster") || item.archived)
        return;
      if (root.ref.previousPoster === item.getMetadata("poster"))
        return;
      root.ref.previousPoster = item.getMetadata("poster");
      if (!query("GET_FILE_POSTER_FILTER_ITEM")(item))
        return;
      if (root.ref.filePoster) {
        view.removeChildView(root.ref.filePoster);
      }
      root.ref.filePoster = view.appendChildView(
        view.createChildView(filePosterView, { id })
      );
      root.dispatch("DID_FILE_POSTER_CONTAINER_CREATE", { id });
    };
    const didCalculatePreviewSize = ({ root, action }) => {
      if (!root.ref.filePoster)
        return;
      root.ref.imageWidth = action.width;
      root.ref.imageHeight = action.height;
      root.ref.shouldUpdatePanelHeight = true;
      root.dispatch("KICK");
    };
    const getPosterHeight = ({ root }) => {
      let fixedPosterHeight = root.query("GET_FILE_POSTER_HEIGHT");
      if (fixedPosterHeight) {
        return fixedPosterHeight;
      }
      const minPosterHeight = root.query("GET_FILE_POSTER_MIN_HEIGHT");
      const maxPosterHeight = root.query("GET_FILE_POSTER_MAX_HEIGHT");
      if (minPosterHeight && root.ref.imageHeight < minPosterHeight) {
        return minPosterHeight;
      }
      let height2 = root.rect.element.width * (root.ref.imageHeight / root.ref.imageWidth);
      if (minPosterHeight && height2 < minPosterHeight) {
        return minPosterHeight;
      }
      if (maxPosterHeight && height2 > maxPosterHeight) {
        return maxPosterHeight;
      }
      return height2;
    };
    view.registerWriter(
      createRoute(
        {
          DID_LOAD_ITEM: didLoadItem,
          DID_FILE_POSTER_CALCULATE_SIZE: didCalculatePreviewSize,
          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata
        },
        ({ root, props }) => {
          if (!root.ref.filePoster)
            return;
          if (root.rect.element.hidden)
            return;
          if (root.ref.shouldUpdatePanelHeight) {
            root.dispatch("DID_UPDATE_PANEL_HEIGHT", {
              id: props.id,
              height: getPosterHeight({ root })
            });
            root.ref.shouldUpdatePanelHeight = false;
          }
        }
      )
    );
  });
  return {
    options: {
      allowFilePoster: [true, Type.BOOLEAN],
      filePosterHeight: [null, Type.INT],
      filePosterMinHeight: [null, Type.INT],
      filePosterMaxHeight: [null, Type.INT],
      filePosterFilterItem: [() => true, Type.FUNCTION],
      filePosterCalculateAverageImageColor: [false, Type.BOOLEAN],
      filePosterCrossOriginAttributeValue: ["Anonymous", Type.STRING],
      filePosterItemOverlayShadowColor: [null, Type.ARRAY],
      filePosterItemOverlayErrorColor: [null, Type.ARRAY],
      filePosterItemOverlaySuccessColor: [null, Type.ARRAY]
    }
  };
};
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin })
  );
}
var filepond_plugin_file_poster_esm_default = plugin;

// dep:filepond-plugin-file-poster
var filepond_plugin_file_poster_default = filepond_plugin_file_poster_esm_default;
export {
  filepond_plugin_file_poster_default as default
};
/*!
 * FilePondPluginFilePoster 2.5.1
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
//# sourceMappingURL=filepond-plugin-file-poster.js.map
